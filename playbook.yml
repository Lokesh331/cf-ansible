# Ansible playbook that uses appliance_console_cli, plus existing
# Ansible modules, to provision a freshly deployed CloudForms appliance.
#

- hosts: cfme
  tags:
    - hostname
  tasks:
    # we assume that static network configuration, if that's what you want,
    # has already been set.

    # set the appliance hostname. we could do this with appliance_console_cli --host, but
    # we don't get the same idempotency as using the module. where ansible modules work, use
    # them.
    - name: set hostname
      shell: "appliance_console_cli --host='{{ inventory_hostname }}'"
      when: inventory_hostname != ansible_fqdn
      tags:
        - set_host

- hosts: cfme
  become: true
  tags:
    - disks
  tasks:
    ##
    # To check if the disk is configured, we take the easy road and
    # check for an existing mount.
    ##
    - set_fact:
        mounts: "{{ ansible_mounts | map(attribute='mount') | list }}"

    - name: configure temporary disk
      shell: "appliance_console_cli --tmpdisk={{cfme_tmpdisk}}"
      when: 
        - cfme_tmpdisk is defined 
        - not "/var/www/miq_tmp" in mounts

    - name: configure log disk
      shell: "appliance_console_cli --logdisk={{cfme_logdisk}}"
      when: 
        - cfme_logdisk is defined
        - not "/var/www/miq/vmdb/log" in mounts

# the next tasks only execute on an appliance that will be the primary
# database. for an all-in-one appliance it will be its own primary db.
# note: you don't want more than one primary database! running in a multi-master
# configuration for postgres isn't supported.
- hosts: primary_db
  become: true
  tags:
    - primary_db
  tasks:
    - name: configure primary database and region
      shell: "appliance_console_cli --internal --username='{{ cfme_db_user }}' --password='{{ cfme_db_pass }}' --region={{ cfme_region }}
        {{ ( '--dbdisk=' + cfme_dbdisk ) if cfme_dbdisk else '' }} --standalone"
      register: primary_db_out
      failed_when: 'primary_db_out.rc > 0 or "Failed" in primary_db_out.stdout'
      args:
        chdir: /var/www/miq/vmdb
        creates: config/database.yml
 
# these plays are designed for hosts that join the database remotely
# we don't need to join an external region, or fetch a remote encryption
# key, if we're building an 'all-in-one' appliance. 
- hosts: non-vmdb[0]
  tasks:
    - set_fact: primary_ip={{ hostvars[groups['primary_db'][0]]['ansible_eth0']['ipv4']['address'] }}

    - name: fetch remote encryption key
      shell: "appliance_console_cli --fetch-key='{{ primary_ip }}' --sshlogin='{{ cfme_ssh_user|default(ansible_user) }}' --sshpassword='{{ cfme_ssh_pass|default(ansible_ssh_pass) }}'"

    - name: create region in database
      shell: "appliance_console_cli --hostname={{ primary_ip }}  --username={{ cfme_db_user }} --password='{{ cfme_db_pass }}' --region={{ cfme_region }}"
      args:
        chdir: /var/www/miq/vmdb
        creates: REGION

    - name: start evmserverd
      service:
        name: evmserverd
        state: started
        enabled: yes
